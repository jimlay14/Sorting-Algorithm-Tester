import java.util.Arrays;



/**
 * A modified ArrayList used only for integers. This allows for the program to store data on comparisons and swaps as it goes,
 * Without worrying about adding different amounts for different numbers of permutations (weakness of a Comparable[])
 * And avoiding the complications of converting to and from a generic ArrayList.
 * 
 * This also allows data obtained from the sorting tests to be analyzed directly.
 *
 * New Methods:
 * 
 *  getArray(): with no parameters, get returns the underlying Comparable[]
 *  sortQuad(): method that allows the IntegerArrayList to sort itself using an insertion sort (for quadratic sort testing)
 * 	sortLinR(): method that allows the IntegerArrayList to sort itself using a merge sort (for use in linearithmic testing)
 *  computeAverage(): computes the average value of items in the list
 *  calculateData(int sortMethod): finds the minimum, maximum, and average value of the array and returns this as a string.
 *  
 *  
 *  EDIT 5/1 - The amount of data generated by making permutations for lists of size 10 or greater is too large for an arraylist ADT to handle.
 *  			Instead, I'll need to use a more feasible HashMap ADT for analyzing data.
 * 
 * @author Joel Ross (in class) & Jacob Imlay
 *
 */
public class AnalyzeableArrayList
{
	private Integer[] array;
	private int size;
	
	private final int INITIAL_CAPACITY = 10;
	//indexes for sort methods referenced in new methods

	public AnalyzeableArrayList()
	{
		this.array = (new Integer[INITIAL_CAPACITY]);
		this.size = 0;
	}
	
	//*********************************************************************
	
	//NEW METHODS
	
	/**
	 * Returns the underlying array
	 * @return The underlying int[]
	 */
	public Integer[] getArray(){
		return array;
	}
	
	/**
	 * Sorts the underlying array using an insertion sort
	 * As a side effect, any null values in the underlying array are cut out to avoid sorting errors
	 */
	public void sortQuad(){
		Integer[] nullCutArray = Arrays.copyOfRange(array, 0, size);
		array = nullCutArray;
		Sorts.insertionSort(array);
	}
	
	/**
	 * Sorts the underlying array using a merge sort (linearithmic),
	 * and as a side effect cuts any null values from the underlying array.
	 */
	public void sortLinR(){
		Integer[] nullCutArray = Arrays.copyOfRange(array, 0, size);
		array = nullCutArray;
		Sorts.mergeSort(array);
	}
	
	
	public void sortJava(){
		Integer[] nullCutArray = Arrays.copyOfRange(array, 0, size);
		array = nullCutArray;
		Arrays.sort(array);
	}
	
	/**
	 * Computes the average of values in the array
	 * @return The average value of the items listed in an array
	 */
	public double computeAverage(){
		double sum = 0;
		for(Integer i : array){
			if(i != null)
				sum += i;
		}
		return sum / this.size;
	}
	
	/**
	 * Calculates the min, max, and average value of integers in the array, and returns a string with those values.
	 * @return A string of the form (min: _minVal_, max: _maxVal_, average: _averageVal_)
	 */
	public String calculateData(){
		this.sortJava();
		return "(min: " + array[0] + ", max: " + array[size-1] + ", average: " + computeAverage() + ")";
	}
	
	
	
	//***********************************************************************
	
	/**
	 * Returns the size of the underlying array
	 * @return size
	 */
	public int size()
	{
		return this.size;
	}
	
	/**
	 * Gets the comparable at a given index
	 * @param index the index to get from
	 * @return The comparable at the given index
	 */
	public Integer get(int index)
	{
		if(index < 0 || index >= size)
			throw new ArrayIndexOutOfBoundsException("Index out of bounds");
			
		return array[index];
	}
	
	/**
	 * Sets the int at a given index
	 * @param index the location of where e will go
	 * @param e the new int to put at the location of index
	 * @return The previous integer at that location, if any
	 */
	public Integer set(int index, Integer e)
	{
		if(index < 0 || index >= size)
			throw new ArrayIndexOutOfBoundsException("Index out of bounds");
		
		Integer old = array[index];
		array[index] = e;
		
		return old;
		
	}
	
	/**
	 * Adds a new comparable to the underlying list
	 * @param index The location to add to the list
	 * @param e The new item
	 */
	public void add(Integer e)
	{
		if(size == array.length) //if filled up
			reallocate(); //embiggen the array
		array[size] = e;		
		size++;
	}
	
	/**
	 * Adds a new comparable to the underlying list
	 * @param index The location to add to the list
	 * @param e The new item
	 */
	public void add(int index, Integer e)
	{
		if(index < 0 || index > size)
			throw new ArrayIndexOutOfBoundsException("Index out of bounds");
	
		if(size == array.length) //if filled up
			reallocate(); //embiggen the array
		
		for(int i=size; i >= index; i--) //shift people over
		{
			array[i] = array[i-1];
		}
		array[index] = e;		
		size++;
	}

	/**
	 * Removes an item from the given index
	 * @param index The location of the item to remove
	 * @return The data at the given location
	 */
	public Integer remove(int index)
	{
		if(index < 0 || index >= size)
			throw new ArrayIndexOutOfBoundsException("Index out of bounds");

		Integer old = array[index];

		for(int i=index; i < size; i++) //shift people over
		{
			array[i] = array[i+1];
		}
		
		return old;
		
	}
	
	/**
	 * Helper method to double the size of the array
	 */
	private void reallocate()
	{
		Integer[] newArray = (new Integer[array.length*2]);
		
		for(int i=0; i < size; i++) //copy everyone over
		{
			newArray[i] = array[i];
		}
		
		array = newArray; //reassign
	}
	
	public String toString(){
		String toReturn = "[";
		for(int i = 0; i < size-1; i++){
			toReturn += array[i] + ", ";
		}
		toReturn += array[size-1] + "]";
		toReturn += "; " + calculateData();
		return toReturn;
	}
	
}
